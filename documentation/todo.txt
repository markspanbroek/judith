x Add Reflection

  x Proxy type which forwards all method calls to a method:

    Reflection.createProxyFor(Object|[
      method call(object, methodname, arguments)
      [
          # do stuff
      ]
    ]|)

  x Add a method caller, which does the reverse:

    Reflection.call(object, methodname, arguments)

x Improve lambda

  x Ensure that lambda's do not introduce a 'self', 'caller', etc...

  x add widgets.all.display

    List := List
    |[
        object Forwarder := Object
        |[
            object list := null

            method create(list)
            [
                object forwarder := self.copy.setList(list)
                result := Reflection.createProxyFor(forwarder)
            ]

            method setList(list')
            [
                list := list'
            ]

            method call(methodName, arguments)
            [
                list.do( [x -> Reflection.call(x, methodName, arguments)] )
            ]
        ]|

        method all
        [
            result := Forwarder.create(self)
        ]
    ]|

* Create a C runtime

* Add CTypes-like library

* Make Judith parser in Judith

    * option 1

        object parser := objects.parsing.Parser.copy
        object r := parser.rules;
        object l := parser.literal;

        # expression = (expression w ("and"|"or") w)? expression1
        r.expression := (r.expression + r.w + (l.text("and") or l.text("or")) + r.w).optional + r.expression1

        # requires an implementation of foo.x := y translated to foo.xBecomes(y)

    * option 2

        object parser := objects.parsing.Parser.copy
        object rules := parser.rules

        rules.expression := "(expression w ('and'|'or') w)? expression1"

        # requires an implementation of foo.x := y translated to foo.xBecomes(y)
        # requires a parser for ebnf

* Make compiler to C

* Make interpreter in judith

* Cleanup

=== optional ====

* Make a list creation method using reflection api

  List.create(1, 2, 3, 4, 5)

  List := List
  |[
      method call(methodName, arguments)
      [
          if methodName == "create" ->
              result := arguments
          || true ->
              result := Reflection.call(self, methodName, arguments)
          fi
      ]
  ]|

  List.replace(Reflection.createProxyFor(List))
