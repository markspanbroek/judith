x Add Reflection

  x Proxy type which forwards all method calls to a method:

    Reflection.createProxyFor(Object|[
      method call(object, methodname, arguments)
      [
          # do stuff
      ]
    ]|)

  x Add a method caller, which does the reverse:

    Reflection.call(object, methodname, arguments)

x Improve lambda

  x Ensure that lambda's do not introduce a 'self', 'caller', etc...

  x add widgets.all.display

    List := List
    |[
        object Forwarder := Object
        |[
            object list := null

            method create(list)
            [
                object forwarder := self.copy.setList(list)
                result := Reflection.createProxyFor(forwarder)
            ]

            method setList(list')
            [
                list := list'
            ]

            method call(methodName, arguments)
            [
                list.do( [x -> Reflection.call(x, methodName, arguments)] )
            ]
        ]|

        method all
        [
            result := Forwarder.create(self)
        ]
    ]|

* Create a C runtime

* Add CTypes-like library

* Make compiler to C

* Make interpreter in judith

* Cleanup

=== optional ====

* Make a list creation method using reflection api

  List.create(1, 2, 3, 4, 5)

  List := List
  |[
      method call(methodName, arguments)
      [
          if methodName == "create" ->
              result := arguments
          || true ->
              result := Reflection.call(self, methodName, arguments)
          fi
      ]
  ]|

  List.replace(Reflection.createProxyFor(List))
